'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

exports.preparePaginationResolver = preparePaginationResolver;

var _graphqlCompose = require('graphql-compose');

var _paginationType = require('./types/paginationType');

var _paginationType2 = _interopRequireDefault(_paginationType);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-param-reassign, no-use-before-define */

var DEFAULT_PER_PAGE = 20;

function preparePaginationResolver(typeComposer, opts) {
  var _this = this;

  if (!(typeComposer instanceof _graphqlCompose.TypeComposer)) {
    throw new Error('First arg for prepareConnectionResolver() should be instance of TypeComposer');
  }

  if (!opts.countResolverName) {
    throw new Error(`TypeComposer(${typeComposer.getTypeName()}) provided to composeWithConnection ` + 'should have option `opts.countResolverName`.');
  }
  var countResolver = typeComposer.getResolver(opts.countResolverName);
  if (!countResolver) {
    throw new Error(`TypeComposer(${typeComposer.getTypeName()}) provided to composeWithConnection ` + `should have resolver with name '${opts.countResolverName}' ` + 'due opts.countResolverName.');
  }
  var countResolve = countResolver.getResolve();

  if (!opts.findResolverName) {
    throw new Error(`TypeComposer(${typeComposer.getTypeName()}) provided to composeWithConnection ` + 'should have option `opts.findResolverName`.');
  }
  var findManyResolver = typeComposer.getResolver(opts.findResolverName);
  if (!findManyResolver) {
    throw new Error(`TypeComposer(${typeComposer.getTypeName()}) provided to composeWithConnection ` + `should have resolver with name '${opts.findResolverName}' ` + 'due opts.countResolverName.');
  }
  var findManyResolve = findManyResolver.getResolve();

  var additionalArgs = {};
  if (findManyResolver.hasArg('filter')) {
    var _filter = findManyResolver.getArg('filter');
    if (_filter) {
      additionalArgs.filter = _filter;
    }
  }
  if (findManyResolver.hasArg('sort')) {
    var _sort = findManyResolver.getArg('sort');
    if (_sort) {
      additionalArgs.sort = _sort;
    }
  }

  return new _graphqlCompose.Resolver({
    type: (0, _paginationType2.default)(typeComposer),
    name: 'pagination',
    kind: 'query',
    args: (0, _extends3.default)({
      page: {
        type: 'Int',
        description: 'Page number for displaying'
      },
      perPage: {
        type: 'Int',
        description: '',
        defaultValue: opts.perPage || DEFAULT_PER_PAGE
      }
    }, additionalArgs),
    // eslint-disable-next-line
    resolve: function () {
      var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(resolveParams) {
        var countPromise, findManyPromise, _resolveParams$projec, projection, args, rawQuery, findManyParams, page, perPage, countParams, limit, skip;

        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                countPromise = void 0;
                findManyPromise = void 0;
                _resolveParams$projec = resolveParams.projection, projection = _resolveParams$projec === undefined ? {} : _resolveParams$projec, args = resolveParams.args, rawQuery = resolveParams.rawQuery;
                findManyParams = (0, _extends3.default)({}, resolveParams);
                page = parseInt(args.page, 10) || 1;

                if (!(page <= 0)) {
                  _context.next = 7;
                  break;
                }

                throw new Error('Argument `page` should be positive number.');

              case 7:
                perPage = parseInt(args.perPage, 10) || opts.perPage || DEFAULT_PER_PAGE;

                if (!(perPage <= 0)) {
                  _context.next = 10;
                  break;
                }

                throw new Error('Argument `perPage` should be positive number.');

              case 10:
                countParams = (0, _extends3.default)({}, resolveParams, {
                  rawQuery,
                  args: {
                    filter: (0, _extends3.default)({}, resolveParams.args.filter)
                  }
                });


                if (projection.count || projection.pageInfo && (projection.pageInfo.itemCount || projection.pageInfo.pageCount)) {
                  countPromise = countResolve(countParams);
                } else {
                  countPromise = Promise.resolve(0);
                }

                if (projection && projection.items) {
                  // combine top level projection
                  // (maybe somebody add additional fields via resolveParams.projection)
                  // and items (record needed fields)
                  findManyParams.projection = (0, _extends3.default)({}, projection, projection.items);
                } else {
                  findManyParams.projection = (0, _extends3.default)({}, projection);
                }

                limit = perPage;
                skip = (page - 1) * perPage;


                findManyParams.args.limit = limit + 1; // +1 document, to check next page presence
                if (skip > 0) {
                  findManyParams.args.skip = skip;
                }

                // pass findMany ResolveParams to top resolver
                resolveParams.findManyResolveParams = findManyParams;
                resolveParams.countResolveParams = countParams;

                // This allows to optimize and not actually call the findMany resolver
                // if only the count is projected
                if ((projection.count || projection.pageInfo) && Object.keys(projection).length === 1) {
                  findManyPromise = Promise.resolve([]);
                } else {
                  findManyPromise = findManyResolve(findManyParams);
                }

                return _context.abrupt('return', Promise.all([findManyPromise, countPromise]).then(function (_ref2) {
                  var _ref3 = (0, _slicedToArray3.default)(_ref2, 2),
                      items = _ref3[0],
                      count = _ref3[1];

                  var result = {
                    count,
                    items: items.length > limit ? items.slice(0, limit) : items,
                    pageInfo: {
                      currentPage: page,
                      perPage,
                      itemCount: count,
                      pageCount: Math.ceil(count / perPage),
                      hasPreviousPage: page > 1,
                      hasNextPage: items.length > limit || page * perPage < count
                    }
                  };
                  return result;
                }));

              case 21:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this);
      }));

      function resolve(_x) {
        return _ref.apply(this, arguments);
      }

      return resolve;
    }()
  });
}