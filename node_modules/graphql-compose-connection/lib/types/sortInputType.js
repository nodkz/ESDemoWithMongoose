'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prepareSortType = prepareSortType;
exports.checkSortOpts = checkSortOpts;

var _graphqlCompose = require('graphql-compose');

var _graphql = require('graphql-compose/lib/graphql');

var _is = require('../utils/is');

function prepareSortType(typeComposer, opts) {
  if (!opts || !opts.sort) {
    throw new Error('Option `sort` should not be empty in composeWithConnection');
  }

  var typeName = `SortConnection${typeComposer.getTypeName()}Enum`;

  var sortKeys = Object.keys(opts.sort);
  if (sortKeys.length === 0) {
    throw new Error('You should provide at least one `sort` option ' + `for composeWithConnection(${typeComposer.getTypeName()}, opts) in opts.sort`);
  }

  var sortEnumValues = {};
  sortKeys.forEach(function (sortKey) {
    checkSortOpts(sortKey, opts.sort[sortKey]);

    sortEnumValues[sortKey] = {
      name: sortKey,
      value: opts.sort[sortKey].value
    };
  });

  var sortType = new _graphql.GraphQLEnumType({
    name: typeName,
    values: sortEnumValues
  });

  return sortType;
}
/* eslint-disable no-use-before-define, no-param-reassign */

function checkSortOpts(key, opts) {
  if (!opts.value) {
    throw new Error('You should provide `value` ' + `for composeWithConnection in opts.sort.${key}. ` + 'Connections does not work without sorting.');
  }

  if (!opts.cursorFields || !Array.isArray(opts.cursorFields)) {
    throw new Error('You should provide array of field(s) in `cursorFields` ' + `for composeWithConnection in opts.sort.${key}` + 'Ideally this field(s) should be in unique index. ' + 'Connection will work incorrectly, if some records have same values.');
  }

  if (!opts.beforeCursorQuery || !(0, _is.isFunction)(opts.beforeCursorQuery)) {
    throw new Error('You should provide `beforeCursorQuery` function ' + `for composeWithConnection in opts.sort.${key}. ` + 'Connections should have ability to filter ' + 'backward records started from cursor.');
  }

  if (!opts.afterCursorQuery || !(0, _is.isFunction)(opts.afterCursorQuery)) {
    throw new Error('You should provide `afterCursorQuery` function ' + `for composeWithConnection in opts.sort.${key}. ` + 'Connections should have ability to filter ' + 'forward records started from cursor.');
  }
}