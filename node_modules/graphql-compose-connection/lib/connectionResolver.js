'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

exports.prepareConnectionResolver = prepareConnectionResolver;
exports.preparePageInfo = preparePageInfo;
exports.prepareRawQuery = prepareRawQuery;
exports.prepareLimitSkipFallback = prepareLimitSkipFallback;
exports.emptyConnection = emptyConnection;
exports.findSortConfig = findSortConfig;

var _graphqlCompose = require('graphql-compose');

var _connectionType = require('./types/connectionType');

var _sortInputType = require('./types/sortInputType');

var _cursor = require('./cursor');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-param-reassign, no-use-before-define */

function prepareConnectionResolver(typeComposer, opts) {
  var _this = this;

  if (!(typeComposer instanceof _graphqlCompose.TypeComposer)) {
    throw new Error('First arg for prepareConnectionResolver() should be instance of TypeComposer');
  }

  if (!opts.countResolverName) {
    throw new Error(`TypeComposer(${typeComposer.getTypeName()}) provided to composeWithConnection ` + 'should have option `opts.countResolverName`.');
  }
  var countResolver = typeComposer.getResolver(opts.countResolverName);
  if (!countResolver) {
    throw new Error(`TypeComposer(${typeComposer.getTypeName()}) provided to composeWithConnection ` + `should have resolver with name '${opts.countResolverName}' ` + 'due opts.countResolverName.');
  }
  var countResolve = countResolver.getResolve();

  if (!opts.findResolverName) {
    throw new Error(`TypeComposer(${typeComposer.getTypeName()}) provided to composeWithConnection ` + 'should have option `opts.findResolverName`.');
  }
  var findManyResolver = typeComposer.getResolver(opts.findResolverName);
  if (!findManyResolver) {
    throw new Error(`TypeComposer(${typeComposer.getTypeName()}) provided to composeWithConnection ` + `should have resolver with name '${opts.findResolverName}' ` + 'due opts.countResolverName.');
  }
  var findManyResolve = findManyResolver.getResolve();

  var additionalArgs = {};
  if (findManyResolver.hasArg('filter')) {
    var _filter = findManyResolver.getArg('filter');
    if (_filter) {
      additionalArgs.filter = _filter;
    }
  }

  var sortEnumType = (0, _sortInputType.prepareSortType)(typeComposer, opts);

  return new _graphqlCompose.Resolver({
    type: (0, _connectionType.prepareConnectionType)(typeComposer),
    name: 'connection',
    kind: 'query',
    args: (0, _extends3.default)({
      first: {
        type: 'Int',
        description: 'Forward pagination argument for returning at most first edges'
      },
      after: {
        type: 'String',
        description: 'Forward pagination argument for returning at most first edges'
      },
      last: {
        type: 'Int',
        description: 'Backward pagination argument for returning at most last edges'
      },
      before: {
        type: 'String',
        description: 'Backward pagination argument for returning at most last edges'
      }
    }, additionalArgs, {
      sort: {
        type: sortEnumType,
        defaultValue: sortEnumType.getValues()[0].value,
        description: 'Sort argument for data ordering'
      }
    }),
    // eslint-disable-next-line
    resolve: function () {
      var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(resolveParams) {
        var countPromise, findManyPromise, _resolveParams$projec, projection, args, rawQuery, findManyParams, first, last, countParams, sortConfig, filteredCountParams, limit, skip, prepareCursorData, _prepareLimitSkipFall, _prepareLimitSkipFall2, skipIdx;

        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                countPromise = void 0;
                findManyPromise = void 0;
                _resolveParams$projec = resolveParams.projection, projection = _resolveParams$projec === undefined ? {} : _resolveParams$projec, args = resolveParams.args, rawQuery = resolveParams.rawQuery;
                findManyParams = (0, _extends3.default)({}, resolveParams);
                first = parseInt(args.first, 10) || 0;

                if (!(first < 0)) {
                  _context.next = 7;
                  break;
                }

                throw new Error('Argument `first` should be non-negative number.');

              case 7:
                last = parseInt(args.last, 10) || 0;

                if (!(last < 0)) {
                  _context.next = 10;
                  break;
                }

                throw new Error('Argument `last` should be non-negative number.');

              case 10:
                countParams = (0, _extends3.default)({}, resolveParams, {
                  rawQuery,
                  args: {
                    filter: (0, _extends3.default)({}, resolveParams.args.filter)
                  }
                });


                if (projection.count) {
                  countPromise = countResolve(countParams);
                } else if (!first && last) {
                  countPromise = countResolve(countParams);
                } else {
                  countPromise = Promise.resolve(0);
                }

                if (projection && projection.edges) {
                  // combine top level projection
                  // (maybe somebody add additional fields via resolveParams.projection)
                  // and edges.node (record needed fields)
                  findManyParams.projection = (0, _extends3.default)({}, projection, projection.edges.node);
                } else {
                  findManyParams.projection = (0, _extends3.default)({}, projection);
                }

                // Apply the rawQuery to the count to get accurate results with last and before
                sortConfig = findSortConfig(opts.sort, args.sort);

                if (sortConfig) {
                  prepareRawQuery(resolveParams, sortConfig);
                }

                if (!(!first && last)) {
                  _context.next = 21;
                  break;
                }

                // Get the number of edges targeted by the findMany resolver (not the whole count)
                filteredCountParams = (0, _extends3.default)({}, resolveParams, {
                  args: {
                    filter: (0, _extends3.default)({}, resolveParams.args.filter)
                  }
                });
                _context.next = 19;
                return countResolve(filteredCountParams);

              case 19:
                first = _context.sent;

                first = parseInt(first, 10) || 0;

              case 21:
                limit = last || first || opts.defaultLimit || 20;
                skip = last > 0 ? first - last : 0;
                prepareCursorData = void 0;

                if (sortConfig) {
                  findManyParams.rawQuery = resolveParams.rawQuery;
                  sortConfig.cursorFields.forEach(function (fieldName) {
                    findManyParams.projection[fieldName] = true;
                  });

                  prepareCursorData = function prepareCursorData(record) {
                    var result = {};
                    sortConfig.cursorFields.forEach(function (fieldName) {
                      result[fieldName] = record[fieldName];
                    });
                    return result;
                  };
                } else {
                  _prepareLimitSkipFall = prepareLimitSkipFallback(resolveParams, limit, skip);
                  _prepareLimitSkipFall2 = (0, _slicedToArray3.default)(_prepareLimitSkipFall, 2);
                  limit = _prepareLimitSkipFall2[0];
                  skip = _prepareLimitSkipFall2[1];
                  skipIdx = -1;
                  // eslint-disable-next-line

                  prepareCursorData = function prepareCursorData(_) {
                    skipIdx += 1;
                    return skip + skipIdx;
                  };
                }

                findManyParams.args.limit = limit + 1; // +1 document, to check next page presence
                if (skip > 0) {
                  findManyParams.args.skip = skip;
                }

                // pass findMany ResolveParams to top resolver
                resolveParams.findManyResolveParams = findManyParams;
                resolveParams.countResolveParams = countParams;

                // This allows to optimize and not actually call the findMany resolver
                // if only the count is projected
                if (projection.count && Object.keys(projection).length === 1) {
                  findManyPromise = Promise.resolve([]);
                } else {
                  findManyPromise = findManyResolve(findManyParams);
                }

                return _context.abrupt('return', Promise.all([findManyPromise, countPromise]).then(function (_ref2) {
                  var _ref3 = (0, _slicedToArray3.default)(_ref2, 2),
                      recordList = _ref3[0],
                      count = _ref3[1];

                  var edges = [];
                  // transform record to object { cursor, node }
                  recordList.forEach(function (record) {
                    edges.push({
                      cursor: (0, _cursor.dataToCursor)(prepareCursorData(record)),
                      node: record
                    });
                  });
                  return [edges, count];
                }).then(function (_ref4) {
                  var _ref5 = (0, _slicedToArray3.default)(_ref4, 2),
                      edges = _ref5[0],
                      count = _ref5[1];

                  var result = emptyConnection();
                  result.edges = edges.length > limit ? edges.slice(0, limit) : edges;

                  result.pageInfo = preparePageInfo(edges, args, limit, skip);
                  result.count = count;

                  return result;
                }));

              case 31:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this);
      }));

      function resolve(_x) {
        return _ref.apply(this, arguments);
      }

      return resolve;
    }()
  });
}

function preparePageInfo(edges, args, limit, skip) {
  var pageInfo = {
    startCursor: '',
    endCursor: '',
    hasPreviousPage: false,
    hasNextPage: false
  };

  var hasExtraRecords = edges.length > limit;

  // pageInfo may be extended, so set data gradually
  if (edges.length > 0 && limit > 0) {
    pageInfo.startCursor = edges[0].cursor;
    if (hasExtraRecords) {
      pageInfo.endCursor = edges[limit - 1].cursor;
    } else {
      pageInfo.endCursor = edges[edges.length - 1].cursor;
    }
    pageInfo.hasPreviousPage = (!!args.last || !args.first) && (skip > 0 || !!args.after);
    pageInfo.hasNextPage = (!!args.first || !args.last) && hasExtraRecords;
  }

  return pageInfo;
}

function prepareRawQuery(rp, sortConfig) {
  if (!rp.rawQuery) {
    rp.rawQuery = {};
  }

  var beginCursorData = (0, _cursor.cursorToData)(rp.args.after);
  if (beginCursorData) {
    var r = sortConfig.afterCursorQuery(rp.rawQuery, beginCursorData, rp);
    if (r !== undefined) {
      rp.rawQuery = r;
    }
  }

  var endCursorData = (0, _cursor.cursorToData)(rp.args.before);
  if (endCursorData) {
    var _r = sortConfig.beforeCursorQuery(rp.rawQuery, endCursorData, rp);
    if (_r !== undefined) {
      rp.rawQuery = _r;
    }
  }
}

function prepareLimitSkipFallback(rp, limit, skip) {
  var newLimit = limit;
  var newSkip = skip;

  var beforeSkip = 0;
  var afterSkip = 0;

  if (rp.args.before) {
    var tmp = (0, _cursor.cursorToData)(rp.args.before);
    if (Number.isInteger(tmp)) {
      beforeSkip = parseInt(tmp, 10);
    }
  }
  if (rp.args.after) {
    var _tmp = (0, _cursor.cursorToData)(rp.args.after);
    if (Number.isInteger(_tmp)) {
      afterSkip = parseInt(_tmp, 10) + 1;
    }
  }

  if (beforeSkip && afterSkip) {
    var rangeLimit = beforeSkip - afterSkip;
    if (rangeLimit < 0) {
      newLimit = 0;
      newSkip = skip + afterSkip;
    } else if (rangeLimit < limit) {
      newLimit = rangeLimit;
      newSkip = skip + beforeSkip - rangeLimit;
    } else {
      newSkip = skip + afterSkip;
    }
  } else if (beforeSkip) {
    newSkip = skip - beforeSkip;
    if (newSkip < 0) {
      newSkip = 0;
      newLimit = limit;
      // offset 0, so limit should not exceed offset in cursor,
      // otherwise it returns again this record
      if (newLimit > beforeSkip) {
        newLimit = beforeSkip;
      }
    }
  } else if (afterSkip) {
    newSkip = afterSkip;
  }

  return [newLimit, newSkip];
}

function emptyConnection() {
  return {
    count: 0,
    edges: [],
    pageInfo: {
      startCursor: '',
      endCursor: '',
      hasPreviousPage: false,
      hasNextPage: false
    }
  };
}

function findSortConfig(configs, val) {
  // Object.keys(configs).forEach(k => {  // return does not works in forEach as I want
  for (var k in configs) {
    if (configs[k].value === val) {
      return configs[k];
    }
  }

  // Yep, I know that it's now good comparision, but fast solution for now
  // Sorry but complex sort value should has same key ordering
  //   cause {a: 1, b: 2} != {b: 2, a: 1}
  // BTW this code will be called only if arg.sort setuped by hands
  //   if graphql provides arg.sort, then first for-loop (above) done all work
  var valStringified = JSON.stringify(val);
  for (var _k in configs) {
    if (JSON.stringify(configs[_k].value) === valStringified) {
      return configs[_k];
    }
  }

  return undefined;
}