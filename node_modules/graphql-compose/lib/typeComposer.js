'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _misc = require('./utils/misc');

var _is = require('./utils/is');

var _configAsThunk = require('./utils/configAsThunk');

var _debug = require('./utils/debug');

var _resolver = require('./resolver');

var _resolver2 = _interopRequireDefault(_resolver);

var _toInputObjectType = require('./toInputObjectType');

var _inputTypeComposer = require('./inputTypeComposer');

var _inputTypeComposer2 = _interopRequireDefault(_inputTypeComposer);

var _typeMapper = require('./typeMapper');

var _typeMapper2 = _interopRequireDefault(_typeMapper);

var _typeByPath = require('./typeByPath');

var _graphql = require('./graphql');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// No type checks for inputs arguments, while waiting new Flow versions.
// eslint-disable-line


// Flow 0.47 not ready for this, it fails with: *** Recursion limit exceeded ***
// // extended GraphQLFieldConfigMap
// export type ComposeFieldConfigMap<TSource, TContext> = {
//   [fieldName: string]:
//     | ComposeFieldConfig<TSource, TContext>
//     | Array<ComposeFieldConfig<TSource, TContext>>
//     | GraphQLFieldConfig<TSource, TContext>,
// } | GraphQLFieldConfigMap<TSource, TContext>;
//
// // extended GraphQLFieldConfig
// export type ComposeFieldConfig<TSource, TContext> =
//   | {
//       type:
//         | ComposeOutputType
//         | Array<ComposeOutputType>,
//       args?: ComposeFieldConfigArgumentMap,
//       resolve?: GraphQLFieldResolver<TSource, TContext>,
//       subscribe?: GraphQLFieldResolver<TSource, TContext>,
//       deprecationReason?: ?string,
//       description?: ?string,
//     }
//   | ComposeOutputType
//   | GraphQLFieldConfig<TSource, TContext>;
//
// // extended GraphQLOutputType
// export type ComposeOutputType =
//   | GraphQLOutputType
//   | TypeComposer
//   | TypeWrappedString
//   | TypeDefinitionString
//   | TypeNameString
//   | Resolver<*, *>
//   | (() => ComposeOutputType);

// Compose Args -----------------------------

// Flow 0.47 not ready for this, it fails with: *** Recursion limit exceeded ***
// export type ComposeArgumentType =
//   | GraphQLInputType
//   | string
//   | InputTypeComposer
//   | GraphQLArgumentConfig
//   | (() => ComposeArgumentType);
// export type ComposeArgumentConfig =
//   | {
//       type: ComposeArgumentType,
//       defaultValue?: mixed,
//       description?: ?string,
//     }
//   | ComposeArgumentType
//   | (() => ComposeArgumentConfig);
// export type ComposeFieldConfigArgumentMap = {
//   [argName: string]: ComposeArgumentConfig | ComposeArgumentConfig[],
// };

// RELATION -----------------------------

/* eslint-disable no-use-before-define */

var TypeComposer = function () {
  (0, _createClass3.default)(TypeComposer, null, [{
    key: 'create',
    value: function create(opts) {
      var TC = void 0;

      if ((0, _is.isString)(opts)) {
        var typeName = opts;
        var NAME_RX = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
        if (NAME_RX.test(typeName)) {
          TC = new TypeComposer(new _graphql.GraphQLObjectType({
            name: typeName,
            fields: function fields() {
              return {};
            }
          }));
        } else {
          var _type = _typeMapper2.default.createType(typeName);
          if (!(_type instanceof _graphql.GraphQLObjectType)) {
            throw new Error('You should provide correct GraphQLObjectType type definition.' + 'Eg. `type MyType { name: String }`');
          }
          TC = new TypeComposer(_type);
        }
      } else if (opts instanceof _graphql.GraphQLObjectType) {
        TC = new TypeComposer(opts);
      } else if ((0, _is.isObject)(opts)) {
        var _type2 = new _graphql.GraphQLObjectType((0, _extends3.default)({}, opts, {
          fields: function fields() {
            return {};
          }
        }));
        TC = new TypeComposer(_type2);

        if ((0, _is.isObject)(opts.fields)) {
          TC.addFields(opts.fields);
        }
      } else {
        throw new Error('You should provide GraphQLObjectTypeConfig or string with type name to TypeComposer.create(opts)');
      }

      return TC;
    }
  }]);

  function TypeComposer(gqType) {
    (0, _classCallCheck3.default)(this, TypeComposer);

    this.gqType = gqType;
  }

  /**
   * Get fields from a GraphQL type
   * WARNING: this method read an internal GraphQL instance variable.
   */


  (0, _createClass3.default)(TypeComposer, [{
    key: 'getFields',
    value: function getFields() {
      if (!this._fields) {
        var _fields = this.gqType._typeConfig.fields;
        this._fields = (0, _misc.resolveMaybeThunk)(_fields) || {};
      }

      return this._fields;
    }
  }, {
    key: 'getFieldNames',
    value: function getFieldNames() {
      return Object.keys(this.getFields());
    }

    /**
     * Completely replace all fields in GraphQL type
     * WARNING: this method rewrite an internal GraphQL instance variable.
     */

  }, {
    key: 'setFields',
    value: function setFields(fields) {
      var _this = this;

      var prepearedFields = _typeMapper2.default.convertOutputFieldConfigMap(fields, this.getTypeName());

      // if field has a projection option, then add it to projection mapper
      Object.keys(prepearedFields).forEach(function (name) {
        if (prepearedFields[name].projection) {
          // $FlowFixMe
          var _projection = prepearedFields[name].projection;
          _this.addProjectionMapper(name, _projection);
        }
      });

      this._fields = prepearedFields;
      this.gqType._typeConfig.fields = function () {
        return (0, _configAsThunk.resolveOutputConfigsAsThunk)(prepearedFields, _this.getTypeName());
      };
      delete this.gqType._fields; // clear builded fields in type
      return this;
    }
  }, {
    key: 'hasField',
    value: function hasField(fieldName) {
      var fields = this.getFields();
      return !!fields[fieldName];
    }
  }, {
    key: 'setField',
    value: function setField(fieldName, fieldConfig) {
      this.addFields({ [fieldName]: fieldConfig });
      return this;
    }

    /**
     * Add new fields or replace existed in a GraphQL type
     */

  }, {
    key: 'addFields',
    value: function addFields(newFields) {
      this.setFields((0, _extends3.default)({}, this.getFields(), newFields));
      return this;
    }

    /**
     * Get fieldConfig by name
     */

  }, {
    key: 'getField',
    value: function getField(fieldName) {
      var fields = this.getFields();

      if (!fields[fieldName]) {
        throw new Error(`Cannot get field '${fieldName}' from type '${this.getTypeName()}'. Field does not exist.`);
      }

      return fields[fieldName];
    }
  }, {
    key: 'removeField',
    value: function removeField(fieldNameOrArray) {
      var fieldNames = Array.isArray(fieldNameOrArray) ? fieldNameOrArray : [fieldNameOrArray];
      var fields = this.getFields();
      fieldNames.forEach(function (fieldName) {
        return delete fields[fieldName];
      });
      this.setFields((0, _extends3.default)({}, fields));
      return this;
    }
  }, {
    key: 'removeOtherFields',
    value: function removeOtherFields(fieldNameOrArray) {
      var keepFieldNames = Array.isArray(fieldNameOrArray) ? fieldNameOrArray : [fieldNameOrArray];
      var fields = this.getFields();
      Object.keys(fields).forEach(function (fieldName) {
        if (keepFieldNames.indexOf(fieldName) === -1) {
          delete fields[fieldName];
        }
      });
      this.setFields(fields);
      return this;
    }
  }, {
    key: 'extendField',
    value: function extendField(fieldName, parialFieldConfig) {
      var prevFieldConfig = void 0;
      try {
        prevFieldConfig = this.getField(fieldName);
      } catch (e) {
        throw new Error(`Cannot extend field '${fieldName}' from type '${this.getTypeName()}'. Field does not exist.`);
      }

      if ((0, _is.isFunction)(prevFieldConfig)) {
        throw new Error(`Cannot extend field '${fieldName}' from type '${this.getTypeName()}'. ` + 'FieldConfig declared as a function. ' + 'Such declaration helps to solve hoisting problems between two types which import each other');
      }

      var fieldConfig = (0, _extends3.default)({}, prevFieldConfig, parialFieldConfig);
      this.setField(fieldName, fieldConfig);
      return this;
    }
  }, {
    key: 'reorderFields',
    value: function reorderFields(names) {
      var orderedFields = {};
      var fields = this.getFields();
      names.forEach(function (name) {
        if (fields[name]) {
          orderedFields[name] = fields[name];
          delete fields[name];
        }
      });
      this.setFields((0, _extends3.default)({}, orderedFields, fields));
      return this;
    }
  }, {
    key: 'addRelation',
    value: function addRelation(fieldName, relationOpts) {
      var _this2 = this;

      if (!this.gqType._gqcRelations) {
        this.gqType._gqcRelations = {};
      }
      this.gqType._gqcRelations[fieldName] = relationOpts;

      // @deprecate remove this check in 3.0.0
      if ((0, _is.isFunction)(relationOpts)) {
        (0, _debug.deprecate)(`${this.getTypeName()}.addRelation('${fieldName}', relationOpts). \n` + 'Argument `relationOpts` cannot be a function from v2.0.0. See https://github.com/nodkz/graphql-compose/releases/tag/2.0.0 \n' + 'Please change `() => ({ resolver: Resolver, ... })` on `{ resolver: () => Resolver, ... }`');
        // eslint-disable-next-line
        relationOpts = relationOpts();
      }

      if (relationOpts.hasOwnProperty('resolver')) {
        this.setField(fieldName, function () {
          // $FlowFixMe
          var fc = _this2._relationWithResolverToFC(relationOpts, fieldName);
          return (0, _extends3.default)({}, fc, { _gqcIsRelation: true });
        });
      } else if (relationOpts.hasOwnProperty('type')) {
        this.setField(fieldName, function () {
          var fc = relationOpts;
          return (0, _extends3.default)({}, fc, { _gqcIsRelation: true });
        });
      }

      return this;
    }
  }, {
    key: 'getRelations',
    value: function getRelations() {
      if (!this.gqType._gqcRelations) {
        this.gqType._gqcRelations = {};
      }
      return this.gqType._gqcRelations;
    }

    /**
    * @deprecated 3.0.0
    */

  }, {
    key: 'buildRelations',
    value: function buildRelations() {
      (0, _debug.deprecate)('No need in calling TC.buildRelations(). You may safely remove call of this method.');
      return this;
    }

    /**
    * @deprecated 3.0.0
    */

  }, {
    key: 'buildRelation',
    value: function buildRelation() {
      (0, _debug.deprecate)('No need in calling TC.buildRelation(). You may safely remove call of this method.');
      return this;
    }
  }, {
    key: '_relationWithResolverToFC',
    value: function _relationWithResolverToFC(opts) {
      var _this3 = this;

      var fieldName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      var resolver = (0, _is.isFunction)(opts.resolver) ? opts.resolver() : opts.resolver;

      if (!(resolver instanceof _resolver2.default)) {
        throw new Error('You should provide correct Resolver object for relation ' + `${this.getTypeName()}.${fieldName}`);
      }
      if (opts.type) {
        throw new Error('You can not use `resolver` and `type` properties simultaneously for relation ' + `${this.getTypeName()}.${fieldName}`);
      }
      if (opts.resolve) {
        throw new Error('You can not use `resolver` and `resolve` properties simultaneously for relation ' + `${this.getTypeName()}.${fieldName}`);
      }

      var fieldConfig = resolver.getFieldConfig();
      var argsConfig = (0, _extends3.default)({}, fieldConfig.args);
      var argsProto = {};
      var argsRuntime = [];

      // remove args from config, if arg name provided in args
      //    if `argMapVal`
      //       is `undefined`, then keep arg field in config
      //       is `null`, then just remove arg field from config
      //       is `function`, then remove arg field and run it in resolve
      //       is any other value, then put it to args prototype for resolve
      var optsArgs = opts.prepareArgs || {};

      /*
      * It's done for better naming. Cause `args` name should be reserver under GraphQLArgConfigMap
      * In terms of graphql-compose `args` is map of preparation functions, so better name is `prepareArgs`
      * @deprecated 3.0.0
      */
      if (opts.args) {
        optsArgs = opts.args;
        (0, _debug.deprecate)(`Please rename 'args' option to 'prepareArgs' in type '${this.getTypeName()}' ` + `in method call addRelation('${fieldName}', { /* rename option 'args' to 'prepareArgs' */ }).`);
      }
      Object.keys(optsArgs).forEach(function (argName) {
        var argMapVal = optsArgs[argName];
        if (argMapVal !== undefined) {
          delete argsConfig[argName];

          if ((0, _is.isFunction)(argMapVal)) {
            argsRuntime.push([argName, argMapVal]);
          } else if (argMapVal !== null) {
            argsProto[argName] = argMapVal;
          }
        }
      });

      // if opts.catchErrors is undefined then set true, otherwise take it value
      var _opts$catchErrors = opts.catchErrors,
          catchErrors = _opts$catchErrors === undefined ? true : _opts$catchErrors;


      var resolve = function resolve(source, args, context, info) {
        var newArgs = (0, _extends3.default)({}, args, argsProto);
        argsRuntime.forEach(function (_ref) {
          var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
              argName = _ref2[0],
              argFn = _ref2[1];

          newArgs[argName] = argFn(source, args, context, info);
        });

        var payload = fieldConfig.resolve ? fieldConfig.resolve(source, newArgs, context, info) : null;
        return catchErrors ? Promise.resolve(payload).catch(function (e) {
          // eslint-disable-next-line
          console.log(`GQC ERROR: relation for ${_this3.getTypeName()}.${fieldName} throws error:`);
          console.log(e); // eslint-disable-line
          return null;
        }) : payload;
      };

      return {
        type: fieldConfig.type,
        description: opts.description,
        deprecationReason: opts.deprecationReason,
        args: argsConfig,
        resolve,
        projection: opts.projection
      };
    }

    /**
     * Get fields from a GraphQL type
     * WARNING: this method read an internal GraphQL instance variable.
     */

  }, {
    key: 'getInterfaces',
    value: function getInterfaces() {
      var interfaces = this.gqType._typeConfig.interfaces;

      if (typeof interfaces === 'function') {
        return interfaces() || [];
      }

      return interfaces || [];
    }

    /**
     * Completely replace all interfaces in GraphQL type
     * WARNING: this method rewrite an internal GraphQL instance variable.
     */

  }, {
    key: 'setInterfaces',
    value: function setInterfaces(interfaces) {
      this.gqType._typeConfig.interfaces = interfaces;
      delete this.gqType._interfaces; // if schema was builded, delete _interfaces
      return this;
    }
  }, {
    key: 'hasInterface',
    value: function hasInterface(interfaceObj) {
      return this.getInterfaces().indexOf(interfaceObj) > -1;
    }
  }, {
    key: 'addInterface',
    value: function addInterface(interfaceObj) {
      if (!this.hasInterface(interfaceObj)) {
        this.setInterfaces([].concat((0, _toConsumableArray3.default)(this.getInterfaces()), [interfaceObj]));
      }
      return this;
    }
  }, {
    key: 'removeInterface',
    value: function removeInterface(interfaceObj) {
      var interfaces = this.getInterfaces();
      var idx = interfaces.indexOf(interfaceObj);
      if (idx > -1) {
        interfaces.splice(idx, 1);
        this.setInterfaces(interfaces);
      }
      return this;
    }
  }, {
    key: 'clone',
    value: function clone(newTypeName) {
      if (!newTypeName) {
        throw new Error('You should provide newTypeName:string for TypeComposer.clone()');
      }

      var fields = this.getFields();
      var newFields = {};
      Object.keys(fields).forEach(function (fieldName) {
        newFields[fieldName] = (0, _extends3.default)({}, fields[fieldName]);
      });

      var cloned = new TypeComposer(new _graphql.GraphQLObjectType({
        name: newTypeName,
        fields: newFields
      }));
      cloned.gqType._gqcProjectionMapper = this.gqType._gqcProjectionMapper;

      cloned.setDescription(this.getDescription());
      try {
        cloned.setRecordIdFn(this.getRecordIdFn());
      } catch (e) {
        // no problem, clone without resolveIdFn
      }
      this.getResolvers().forEach(function (resolver) {
        var newResolver = resolver.clone(cloned);
        cloned.addResolver(newResolver);
      });

      return cloned;
    }

    /**
     * Get fieldType by name
     */

  }, {
    key: 'getFieldType',
    value: function getFieldType(fieldName) {
      var field = this.getField(fieldName);
      if (!field) {
        throw new Error(`Type ${this.getTypeName()} does not have field with name '${fieldName}'`);
      }

      return field.type;
    }
  }, {
    key: 'getFieldTC',
    value: function getFieldTC(fieldName) {
      var fieldType = (0, _graphql.getNamedType)(this.getFieldType(fieldName));
      if (!(fieldType instanceof _graphql.GraphQLObjectType)) {
        throw new Error(`Cannot get TypeComposer for field '${fieldName}' in type ${this.getTypeName()}. ` + `This field should be ObjectType, but it has type '${fieldType.constructor.name}'`);
      }
      return TypeComposer.create(fieldType);
    }
  }, {
    key: 'getType',
    value: function getType() {
      return this.gqType;
    }
  }, {
    key: 'getTypePlural',
    value: function getTypePlural() {
      return new _graphql.GraphQLList(this.gqType);
    }
  }, {
    key: 'getInputType',
    value: function getInputType() {
      return this.getInputTypeComposer().getType();
    }
  }, {
    key: 'hasInputTypeComposer',
    value: function hasInputTypeComposer() {
      return !!this.gqType._gqcInputTypeComposer;
    }
  }, {
    key: 'getInputTypeComposer',
    value: function getInputTypeComposer() {
      if (!this.gqType._gqcInputTypeComposer) {
        this.gqType._gqcInputTypeComposer = (0, _toInputObjectType.toInputObjectType)(this);
      }

      return this.gqType._gqcInputTypeComposer;
    }
  }, {
    key: 'getResolvers',
    value: function getResolvers() {
      if (!this.gqType._gqcResolvers) {
        this.gqType._gqcResolvers = new Map();
      }
      return this.gqType._gqcResolvers;
    }
  }, {
    key: 'hasResolver',
    value: function hasResolver(name) {
      if (!this.gqType._gqcResolvers) {
        return false;
      }
      return this.gqType._gqcResolvers.has(name);
    }
  }, {
    key: 'getResolver',
    value: function getResolver(name) {
      // $FlowFixMe
      if (!this.hasResolver(name) || !this.gqType._gqcResolvers) {
        throw new Error(`Type ${this.getTypeName()} does not have resolver with name '${name}'`);
      }
      return this.gqType._gqcResolvers.get(name);
    }
  }, {
    key: 'setResolver',
    value: function setResolver(name, resolver) {
      if (!this.gqType._gqcResolvers) {
        this.gqType._gqcResolvers = new Map();
      }
      if (!(resolver instanceof _resolver2.default)) {
        throw new Error('setResolver() accept only Resolver instance');
      }
      this.gqType._gqcResolvers.set(name, resolver);
      resolver.setDisplayName(`${this.getTypeName()}.${resolver.name}`);
      return this;
    }
  }, {
    key: 'addResolver',
    value: function addResolver(resolver) {
      if (!(resolver instanceof _resolver2.default)) {
        resolver = new _resolver2.default(resolver); // eslint-disable-line no-param-reassign
      }

      if (!resolver.name) {
        throw new Error('resolver should have non-empty name property');
      }
      this.setResolver(resolver.name, resolver);
      return this;
    }
  }, {
    key: 'removeResolver',
    value: function removeResolver(resolverName) {
      if (resolverName) {
        this.getResolvers().delete(resolverName);
      }
      return this;
    }
  }, {
    key: 'wrapResolver',
    value: function wrapResolver(resolverName, cbResolver) {
      var resolver = this.getResolver(resolverName);
      var newResolver = resolver.wrap(cbResolver);
      this.setResolver(resolverName, newResolver);
      return this;
    }
  }, {
    key: 'wrapResolverAs',
    value: function wrapResolverAs(resolverName, fromResolverName, cbResolver) {
      var resolver = this.getResolver(fromResolverName);
      var newResolver = resolver.wrap(cbResolver);
      this.setResolver(resolverName, newResolver);
      return this;
    }
  }, {
    key: 'wrapResolverResolve',
    value: function wrapResolverResolve(resolverName, cbNextRp) {
      var resolver = this.getResolver(resolverName);
      this.setResolver(resolverName, resolver.wrapResolve(cbNextRp));
      return this;
    }
  }, {
    key: 'getTypeName',
    value: function getTypeName() {
      return this.gqType.name;
    }
  }, {
    key: 'setTypeName',
    value: function setTypeName(name) {
      this.gqType.name = name;
      return this;
    }
  }, {
    key: 'getDescription',
    value: function getDescription() {
      return this.gqType.description || '';
    }
  }, {
    key: 'setDescription',
    value: function setDescription(description) {
      this.gqType.description = description;
      return this;
    }
  }, {
    key: 'setRecordIdFn',
    value: function setRecordIdFn(fn) {
      this.gqType._gqcGetRecordIdFn = fn;
      return this;
    }
  }, {
    key: 'hasRecordIdFn',
    value: function hasRecordIdFn() {
      return !!this.gqType._gqcGetRecordIdFn;
    }
  }, {
    key: 'getRecordIdFn',
    value: function getRecordIdFn() {
      if (!this.gqType._gqcGetRecordIdFn) {
        throw new Error(`Type ${this.getTypeName()} does not have RecordIdFn`);
      }
      return this.gqType._gqcGetRecordIdFn;
    }
    /**
    * Get function that returns record id, from provided object.
    */

  }, {
    key: 'getRecordId',
    value: function getRecordId(source, args, context) {
      return this.getRecordIdFn()(source, args, context);
    }
  }, {
    key: 'getFieldArgs',
    value: function getFieldArgs(fieldName) {
      try {
        var field = this.getField(fieldName);
        return field.args || {};
      } catch (e) {
        throw new Error(`Cannot get field args. Field '${fieldName}' from type '${this.getTypeName()}' does not exist.`);
      }
    }
  }, {
    key: 'hasFieldArg',
    value: function hasFieldArg(fieldName, argName) {
      var fieldArgs = this.getFieldArgs(fieldName);
      return !!fieldArgs[argName];
    }
  }, {
    key: 'getFieldArg',
    value: function getFieldArg(fieldName, argName) {
      var fieldArgs = this.getFieldArgs(fieldName);

      if (!fieldArgs[argName]) {
        throw new Error(`Cannot get arg '${argName}' from type.field '${this.getTypeName()}.${fieldName}'. Argument does not exist.`);
      }

      return fieldArgs[argName];
    }
  }, {
    key: 'get',
    value: function get(path) {
      return (0, _typeByPath.typeByPath)(this, path);
    }

    // Sometimes, when you create relations or some tricky fields,
    // you should have a data from additional fields, that not in a query projection.
    // E.g. for obtaining `friendList` you also should add `friendIds` to projection.
    //      or for `fullname` field you should request `firstname` and `lastname` from DB.
    // this _gqcProjectionMapper used in `projection` module

  }, {
    key: 'addProjectionMapper',
    value: function addProjectionMapper(fieldName, sourceProjection) {
      if (!this.gqType._gqcProjectionMapper) {
        this.gqType._gqcProjectionMapper = {};
      }
      this.gqType._gqcProjectionMapper[fieldName] = sourceProjection;
      return this;
    }
  }, {
    key: 'getProjectionMapper',
    value: function getProjectionMapper() {
      return this.gqType._gqcProjectionMapper || {};
    }
  }, {
    key: 'deprecateFields',
    value: function deprecateFields(fields) {
      var _this4 = this;

      var existedFieldNames = this.getFieldNames();

      if (typeof fields === 'string') {
        if (existedFieldNames.indexOf(fields) === -1) {
          throw new Error(`Cannot deprecate unexisted field '${fields}' from type '${this.getTypeName()}'`);
        }
        this.extendField(fields, { deprecationReason: 'deprecated' });
      } else if (Array.isArray(fields)) {
        fields.forEach(function (field) {
          if (existedFieldNames.indexOf(field) === -1) {
            throw new Error(`Cannot deprecate unexisted field '${field}' from type '${_this4.getTypeName()}'`);
          }
          _this4.extendField(field, { deprecationReason: 'deprecated' });
        });
      } else {
        Object.keys(fields).forEach(function (field) {
          if (existedFieldNames.indexOf(field) === -1) {
            throw new Error(`Cannot deprecate unexisted field '${field}' from type '${_this4.getTypeName()}'`);
          }
          // $FlowFixMe
          var deprecationReason = fields[field];
          _this4.extendField(field, { deprecationReason });
        });
      }

      return this;
    }
  }]);
  return TypeComposer;
}();

exports.default = TypeComposer;