'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _graphql = require('./graphql');

var _misc = require('./utils/misc');

var _is = require('./utils/is');

var _configAsThunk = require('./utils/configAsThunk');

var _typeMapper = require('./typeMapper');

var _typeMapper2 = _interopRequireDefault(_typeMapper);

var _typeByPath = require('./typeByPath');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Flow 0.47 not ready for this, it fails with: *** Recursion limit exceeded ***
// export type ComposeInputFieldConfigMap = {
//   [fieldName: string]:
//     | ComposeInputFieldConfig
//     | Array<ComposeInputFieldConfig>
//     | GraphQLInputFieldConfig,
// } | GraphQLInputFieldConfigMap;
//
// export type ComposeInputFieldConfig =
//   | {
//       type: ComposeInputType | Array<ComposeInputType>,
//       defaultValue?: mixed,
//       description?: ?string,
//     }
//   | ComposeInputType
//   | GraphQLInputFieldConfig;
//
// export type ComposeInputType =
//   | InputTypeComposer
//   | GraphQLInputType
//   | TypeWrappedString
//   | TypeDefinitionString
//   | TypeNameString
//   | (() => ComposeInputType);

// import { deprecate } from './utils/debug';
var InputTypeComposer = function () {
  (0, _createClass3.default)(InputTypeComposer, null, [{
    key: 'create',
    value: function create(opts) {
      var ITC = void 0;

      if ((0, _is.isString)(opts)) {
        var typeName = opts;
        var NAME_RX = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
        if (NAME_RX.test(typeName)) {
          ITC = new InputTypeComposer(new _graphql.GraphQLInputObjectType({
            name: typeName,
            fields: function fields() {
              return {};
            }
          }));
        } else {
          var type = _typeMapper2.default.createType(typeName);
          if (!(type instanceof _graphql.GraphQLInputObjectType)) {
            throw new Error('You should provide correct GraphQLInputObjectType type definition.' + 'Eg. `input MyInputType { name: String! }`');
          }
          ITC = new InputTypeComposer(type);
        }
      } else if (opts instanceof _graphql.GraphQLInputObjectType) {
        ITC = new InputTypeComposer(opts);
      } else if ((0, _is.isObject)(opts)) {
        var _type = new _graphql.GraphQLInputObjectType({
          name: opts.name,
          description: opts.description,
          fields: function fields() {
            return {};
          }
        });
        ITC = new InputTypeComposer(_type);

        if ((0, _is.isObject)(opts.fields)) {
          ITC.addFields(opts.fields);
        }
      } else {
        throw new Error('You should provide InputObjectConfig or string with type name to InputTypeComposer.create(opts)');
      }

      return ITC;
    }
  }]);

  function InputTypeComposer(gqType) {
    (0, _classCallCheck3.default)(this, InputTypeComposer);

    if (!(gqType instanceof _graphql.GraphQLInputObjectType)) {
      throw new Error('InputTypeComposer accept only GraphQLInputObjectType in constructor');
    }
    this.gqType = gqType;
  }

  /**
   * Get fields from a GraphQL type
   * WARNING: this method read an internal GraphQL instance variable.
   */


  (0, _createClass3.default)(InputTypeComposer, [{
    key: 'getFields',
    value: function getFields() {
      var fields = this.gqType._typeConfig.fields;

      var fieldMap = (0, _configAsThunk.keepConfigsAsThunk)((0, _misc.resolveMaybeThunk)(fields));

      if ((0, _is.isObject)(fieldMap)) {
        return (0, _extends3.default)({}, fieldMap);
      }
      return {};
    }
  }, {
    key: 'getFieldNames',
    value: function getFieldNames() {
      return Object.keys(this.getFields());
    }
  }, {
    key: 'hasField',
    value: function hasField(fieldName) {
      var fields = this.getFields();
      return !!fields[fieldName];
    }

    /**
     * Completely replace all fields in GraphQL type
     * WARNING: this method rewrite an internal GraphQL instance variable.
     */

  }, {
    key: 'setFields',
    value: function setFields(fields) {
      var _this = this;

      var prepearedFields = _typeMapper2.default.convertInputFieldConfigMap(fields, this.getTypeName());

      this.gqType._typeConfig.fields = function () {
        return (0, _configAsThunk.resolveInputConfigsAsThunk)(prepearedFields, _this.getTypeName());
      };
      delete this.gqType._fields; // if schema was builded, delete defineFieldMap
      return this;
    }
  }, {
    key: 'setField',
    value: function setField(fieldName, fieldConfig) {
      this.addFields({ [fieldName]: fieldConfig });
      return this;
    }

    /**
     * Add new fields or replace existed in a GraphQL type
     */

  }, {
    key: 'addFields',
    value: function addFields(newFields) {
      this.setFields((0, _extends3.default)({}, this.getFields(), newFields));
      return this;
    }

    /**
     * Get fieldConfig by name
     */

  }, {
    key: 'getField',
    value: function getField(fieldName) {
      var fields = this.getFields();

      if (!fields[fieldName]) {
        throw new Error(`Cannot get field '${fieldName}' from input type '${this.getTypeName()}'. Field does not exist.`);
      }

      return fields[fieldName];
    }
  }, {
    key: 'removeField',
    value: function removeField(fieldNameOrArray) {
      var fieldNames = Array.isArray(fieldNameOrArray) ? fieldNameOrArray : [fieldNameOrArray];
      var fields = this.getFields();
      fieldNames.forEach(function (fieldName) {
        return delete fields[fieldName];
      });
      this.setFields(fields);
      return this;
    }
  }, {
    key: 'removeOtherFields',
    value: function removeOtherFields(fieldNameOrArray) {
      var keepFieldNames = Array.isArray(fieldNameOrArray) ? fieldNameOrArray : [fieldNameOrArray];
      var fields = this.getFields();
      Object.keys(fields).forEach(function (fieldName) {
        if (keepFieldNames.indexOf(fieldName) === -1) {
          delete fields[fieldName];
        }
      });
      this.setFields(fields);
      return this;
    }
  }, {
    key: 'extendField',
    value: function extendField(fieldName, parialFieldConfig) {
      var prevFieldConfig = void 0;
      try {
        prevFieldConfig = this.getField(fieldName);
      } catch (e) {
        throw new Error(`Cannot extend field '${fieldName}' from input type '${this.getTypeName()}'. Field does not exist.`);
      }

      var fieldConfig = (0, _extends3.default)({}, prevFieldConfig, parialFieldConfig);
      this.setField(fieldName, fieldConfig);
      return this;
    }
  }, {
    key: 'reorderFields',
    value: function reorderFields(names) {
      var orderedFields = {};
      var fields = this.getFields();
      names.forEach(function (name) {
        if (fields[name]) {
          orderedFields[name] = fields[name];
          delete fields[name];
        }
      });
      this.setFields((0, _extends3.default)({}, orderedFields, fields));
      return this;
    }
  }, {
    key: 'isRequired',
    value: function isRequired(fieldName) {
      return this.getFieldType(fieldName) instanceof _graphql.GraphQLNonNull;
    }
  }, {
    key: 'getFieldType',
    value: function getFieldType(fieldName) {
      var field = this.getField(fieldName);
      if (!field) {
        throw new Error(`Type ${this.getTypeName()} does not have field with name '${fieldName}'`);
      }

      return field.type;
    }
  }, {
    key: 'getFieldTC',
    value: function getFieldTC(fieldName) {
      var fieldType = (0, _graphql.getNamedType)(this.getFieldType(fieldName));
      if (!(fieldType instanceof _graphql.GraphQLInputObjectType)) {
        throw new Error(`Cannot get InputTypeComposer for field '${fieldName}' in type ${this.getTypeName()}. ` + `This field should be InputObjectType, but it has type '${fieldType.constructor.name}'`);
      }
      return InputTypeComposer.create(fieldType);
    }
  }, {
    key: 'makeRequired',
    value: function makeRequired(fieldNameOrArray) {
      var fieldNames = Array.isArray(fieldNameOrArray) ? fieldNameOrArray : [fieldNameOrArray];
      var fields = this.getFields();
      fieldNames.forEach(function (fieldName) {
        if (fields[fieldName] && fields[fieldName].type) {
          if (!(fields[fieldName].type instanceof _graphql.GraphQLNonNull)) {
            fields[fieldName].type = new _graphql.GraphQLNonNull(fields[fieldName].type);
          }
        }
      });
      this.setFields(fields);
      return this;
    }
  }, {
    key: 'makeOptional',
    value: function makeOptional(fieldNameOrArray) {
      var fieldNames = Array.isArray(fieldNameOrArray) ? fieldNameOrArray : [fieldNameOrArray];
      var fields = this.getFields();
      fieldNames.forEach(function (fieldName) {
        if (fieldNames.indexOf(fieldName) > -1) {
          if (fields[fieldName] && fields[fieldName].type instanceof _graphql.GraphQLNonNull) {
            fields[fieldName].type = fields[fieldName].type.ofType;
          }
        }
      });
      this.setFields(fields);
      return this;
    }
  }, {
    key: 'clone',
    value: function clone(newTypeName) {
      if (!newTypeName) {
        throw new Error('You should provide new type name for clone() method');
      }

      var fields = this.getFields();
      var newFields = {};
      Object.keys(fields).forEach(function (fieldName) {
        newFields[fieldName] = (0, _extends3.default)({}, fields[fieldName]);
      });

      return new InputTypeComposer(new _graphql.GraphQLInputObjectType({
        name: newTypeName,
        fields: newFields
      }));
    }
  }, {
    key: 'getType',
    value: function getType() {
      return this.gqType;
    }
  }, {
    key: 'getTypeAsRequired',
    value: function getTypeAsRequired() {
      return new _graphql.GraphQLNonNull(this.gqType);
    }
  }, {
    key: 'getTypeName',
    value: function getTypeName() {
      return this.gqType.name;
    }
  }, {
    key: 'setTypeName',
    value: function setTypeName(name) {
      this.gqType.name = name;
      return this;
    }
  }, {
    key: 'getDescription',
    value: function getDescription() {
      return this.gqType.description || '';
    }
  }, {
    key: 'setDescription',
    value: function setDescription(description) {
      this.gqType.description = description;
      return this;
    }
  }, {
    key: 'get',
    value: function get(path) {
      return (0, _typeByPath.typeByPath)(this, path);
    }
  }]);
  return InputTypeComposer;
}();

exports.default = InputTypeComposer;