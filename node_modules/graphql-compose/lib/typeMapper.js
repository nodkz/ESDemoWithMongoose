'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

exports.isOutputType = isOutputType;
exports.isInputType = isInputType;

var _objectPath = require('object-path');

var _objectPath2 = _interopRequireDefault(_objectPath);

var _parser = require('graphql/language/parser');

var _kinds = require('graphql/language/kinds');

var _buildASTSchema = require('graphql/utilities/buildASTSchema');

var _keyValMap = require('graphql/jsutils/keyValMap');

var _keyValMap2 = _interopRequireDefault(_keyValMap);

var _invariant = require('graphql/jsutils/invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _find = require('graphql/jsutils/find');

var _find2 = _interopRequireDefault(_find);

var _values = require('graphql/execution/values');

var _graphql = require('./graphql');

var _json = require('./type/json');

var _json2 = _interopRequireDefault(_json);

var _date = require('./type/date');

var _date2 = _interopRequireDefault(_date);

var _is = require('./utils/is');

var _typeComposer = require('./typeComposer');

var _typeComposer2 = _interopRequireDefault(_typeComposer);

var _inputTypeComposer = require('./inputTypeComposer');

var _inputTypeComposer2 = _interopRequireDefault(_inputTypeComposer);

var _resolver = require('./resolver');

var _resolver2 = _interopRequireDefault(_resolver);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eg. Int, Float

// eg. Int, Int!, [Int]
function isOutputType(type) {
  return type instanceof _graphql.GraphQLScalarType || type instanceof _graphql.GraphQLObjectType || type instanceof _graphql.GraphQLInterfaceType || type instanceof _graphql.GraphQLUnionType || type instanceof _graphql.GraphQLEnumType || type instanceof _graphql.GraphQLNonNull && isOutputType(type.ofType) || type instanceof _graphql.GraphQLList && isOutputType(type.ofType);
}
/* eslint-disable no-use-before-define, class-methods-use-this, no-unused-vars, no-param-reassign */

function isInputType(type) {
  return type instanceof _graphql.GraphQLScalarType || type instanceof _graphql.GraphQLEnumType || type instanceof _graphql.GraphQLInputObjectType || type instanceof _graphql.GraphQLNonNull && isInputType(type.ofType) || type instanceof _graphql.GraphQLList && isInputType(type.ofType);
}

var RegexpOutputTypeDefinition = /type\s[^{]+\{[^}]+\}/im;
var RegexpInputTypeDefinition = /input\s[^{]+\{[^}]+\}/im;
var RegexpEnumTypeDefinition = /enum\s[^{]+\{[^}]+\}/im;

var TypeMapper = function () {
  function TypeMapper() {
    (0, _classCallCheck3.default)(this, TypeMapper);

    this.map = new Map();

    this.addBasicScalarTypes();
  }

  (0, _createClass3.default)(TypeMapper, [{
    key: 'get',
    value: function get(name) {
      return this.map.get(name);
    }
  }, {
    key: 'set',
    value: function set(name, type) {
      this.map.set(name, type);
    }
  }, {
    key: 'has',
    value: function has(name) {
      return this.map.has(name);
    }
  }, {
    key: 'delete',
    value: function _delete(name) {
      return this.map.delete(name);
    }
  }, {
    key: 'keys',
    value: function keys() {
      // eslint-disable-line no-undef
      return this.map.keys();
    }
  }, {
    key: 'addBasicScalarTypes',
    value: function addBasicScalarTypes() {
      this.set('String', _graphql.GraphQLString);
      this.set('Float', _graphql.GraphQLFloat);
      this.set('Int', _graphql.GraphQLInt);
      this.set('Boolean', _graphql.GraphQLBoolean);
      this.set('ID', _graphql.GraphQLID);
      this.set('JSON', _json2.default);
      this.set('Json', _json2.default);
      this.set('Date', _date2.default);
    }
  }, {
    key: 'getWrapped',
    value: function getWrapped(str) {
      var inputTypeAST = (0, _parser.parseType)(str);
      return typeFromAST(inputTypeAST);
    }
  }, {
    key: 'createType',
    value: function createType(str) {
      var astDocument = (0, _parser.parse)(str);

      if (_objectPath2.default.get(astDocument, 'kind') !== 'Document') {
        throw new Error('You should provide correct type syntax. ' + "Eg. createType('type IntRange { min: Int, max: Int }')");
      }

      var types = parseTypes(astDocument);

      var type = types[0];

      if (type) {
        this.set(type.name, type);
        return type;
      }

      return undefined;
    }
  }, {
    key: 'convertOutputFieldConfig',
    value: function convertOutputFieldConfig(composeFC) {
      var fieldName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var typeName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

      var composeType = void 0;

      if (composeFC instanceof _graphql.GraphQLList || composeFC instanceof _graphql.GraphQLNonNull) {
        return { type: composeFC };
      } else if (composeFC instanceof _resolver2.default) {
        return composeFC.getFieldConfig();
      } else if (composeFC instanceof _typeComposer2.default) {
        return {
          type: composeFC.getType(),
          description: composeFC.getDescription()
        };
      } else if (Array.isArray(composeFC)) {
        composeType = composeFC;
        composeFC = {};
      } else if ((0, _is.isFunction)(composeFC)) {
        return composeFC;
      } else if (composeFC.type) {
        composeType = composeFC.type;
      } else {
        composeType = composeFC;
        composeFC = {};
      }

      var wrapWithList = false;
      if (Array.isArray(composeType)) {
        if (composeType.length !== 1) {
          throw new Error(`${typeName}.${fieldName} can accept Array exact with one output type definition`);
        }
        wrapWithList = true;
        composeType = composeType[0];

        if (Array.isArray(composeType)) {
          throw new Error(`${typeName}.${fieldName} definition [[Type]] (array of array) does not supported`);
        }
      }

      if (composeType instanceof _inputTypeComposer2.default) {
        throw new Error(`You cannot provide InputTypeComposer to the field '${typeName}.${fieldName}'. It should be OutputType.`);
      }

      var fieldConfig = {};
      if (typeof composeType === 'string') {
        if (RegexpInputTypeDefinition.test(composeType)) {
          throw new Error(`${typeName}.${fieldName} should be OutputType, but got input type definition '${composeType}'`);
        }

        var type = RegexpOutputTypeDefinition.test(composeType) || RegexpEnumTypeDefinition.test(composeType) ? this.createType(composeType) : this.getWrapped(composeType);

        if (!type) {
          throw new Error(`${typeName}.${fieldName} cannot convert to OutputType the following string: '${composeType}'`);
        }

        // $FlowFixMe
        fieldConfig.type = type;
      } else if (composeType instanceof _typeComposer2.default) {
        fieldConfig.type = composeType.getType();
      } else if (composeType instanceof _resolver2.default) {
        fieldConfig.type = composeType.getType();
      } else {
        fieldConfig.type = composeType;
      }

      if (!fieldConfig.type) {
        throw new Error(`${typeName}.${fieldName} must have some 'type'`);
      }

      if (!(0, _is.isFunction)(fieldConfig.type)) {
        if (!isOutputType(fieldConfig.type)) {
          throw new Error(`${typeName}.${fieldName} provided incorrect OutputType: '${JSON.stringify(composeType)}'`);
        }

        if (wrapWithList) {
          fieldConfig.type = new _graphql.GraphQLList(fieldConfig.type);
        }
      }

      if ((0, _is.isObject)(composeFC)) {
        if (composeFC.args) {
          fieldConfig.args = this.convertArgConfigMap(composeFC.args, fieldName, typeName);
        }

        // copy all other props
        var doNotCopy = ['type', 'args'];
        for (var prop in composeFC) {
          if (composeFC.hasOwnProperty(prop) && doNotCopy.indexOf(prop) === -1) {
            fieldConfig[prop] = composeFC[prop];
          }
        }
      }

      return fieldConfig;
    }
  }, {
    key: 'convertOutputFieldConfigMap',
    value: function convertOutputFieldConfigMap(composeFields) {
      var _this = this;

      var typeName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      var fields = {};
      Object.keys(composeFields).forEach(function (name) {
        fields[name] = _this.convertOutputFieldConfig(composeFields[name], name, typeName);
      });

      return fields;
    }
  }, {
    key: 'convertArgConfig',
    value: function convertArgConfig(composeAC) {
      var argName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var fieldName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var typeName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

      var composeType = void 0;

      if (composeAC instanceof _graphql.GraphQLList || composeAC instanceof _graphql.GraphQLNonNull) {
        return { type: composeAC };
      } else if (composeAC instanceof _inputTypeComposer2.default) {
        return {
          type: composeAC.getType(),
          description: composeAC.getDescription()
        };
      } else if (Array.isArray(composeAC)) {
        composeType = composeAC;
        composeAC = {};
      } else if ((0, _is.isFunction)(composeAC)) {
        return composeAC;
      } else if (composeAC.type) {
        composeType = composeAC.type;
      } else {
        composeType = composeAC;
        composeAC = {};
      }

      var wrapWithList = false;
      if (Array.isArray(composeType)) {
        if (composeType.length !== 1) {
          throw new Error(`${typeName}.${fieldName}@${argName} can accept Array exact with one input type definition`);
        }
        wrapWithList = true;
        composeType = composeType[0];

        if (Array.isArray(composeType)) {
          throw new Error(`${typeName}.${fieldName}@${argName} definition [[Type]] (array of array) does not supported`);
        }
      }

      if (composeType instanceof _typeComposer2.default) {
        throw new Error(`You cannot provide TypeComposer to the arg '${typeName}.${fieldName}.@${argName}'. It should be InputType.`);
      }

      var argConfig = {};
      if (typeof composeType === 'string') {
        if (RegexpOutputTypeDefinition.test(composeType)) {
          throw new Error(`${typeName}.${fieldName}@${argName} should be InputType, but got output type definition '${composeType}'`);
        }

        var type = RegexpInputTypeDefinition.test(composeType) || RegexpEnumTypeDefinition.test(composeType) ? this.createType(composeType) : this.getWrapped(composeType);

        if (!type) {
          throw new Error(`${typeName}.${fieldName}@${argName} cannot convert to InputType the following string: '${composeType}'`);
        }

        // $FlowFixMe
        argConfig.type = type;
      } else if (composeType instanceof _inputTypeComposer2.default) {
        argConfig.type = composeType.getType();
      } else {
        argConfig.type = composeType;
      }

      if (!argConfig.type) {
        throw new Error(`${typeName}.${fieldName}@${argName} must have some 'type'`);
      }

      if (!(0, _is.isFunction)(argConfig.type)) {
        if (!isInputType(argConfig.type)) {
          throw new Error(`${typeName}.${fieldName}@${argName} provided incorrect InputType: '${JSON.stringify(composeType)}'`);
        }

        if (wrapWithList) {
          argConfig.type = new _graphql.GraphQLList(argConfig.type);
        }
      }

      if ((0, _is.isObject)(composeAC)) {
        // copy all other props
        var doNotCopy = ['type'];
        for (var prop in composeAC) {
          if (composeAC.hasOwnProperty(prop) && doNotCopy.indexOf(prop) === -1) {
            argConfig[prop] = composeAC[prop];
          }
        }
      }

      return argConfig;
    }
  }, {
    key: 'convertArgConfigMap',
    value: function convertArgConfigMap(composeArgsConfigMap) {
      var _this2 = this;

      var fieldName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var typeName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

      var argsConfigMap = {};
      if (composeArgsConfigMap) {
        Object.keys(composeArgsConfigMap).forEach(function (argName) {
          argsConfigMap[argName] = _this2.convertArgConfig(composeArgsConfigMap[argName], argName, fieldName, typeName);
        });
      }

      return argsConfigMap;
    }
  }, {
    key: 'convertInputFieldConfig',
    value: function convertInputFieldConfig(composeIFC) {
      var fieldName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var typeName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

      var composeType = void 0;

      if (composeIFC instanceof _graphql.GraphQLList || composeIFC instanceof _graphql.GraphQLNonNull) {
        return { type: composeIFC };
      } else if (composeIFC instanceof _inputTypeComposer2.default) {
        return {
          type: composeIFC.getType(),
          description: composeIFC.getDescription()
        };
      } else if (Array.isArray(composeIFC)) {
        composeType = composeIFC;
        composeIFC = {};
      } else if ((0, _is.isFunction)(composeIFC)) {
        return composeIFC;
      } else if (composeIFC.type) {
        composeType = composeIFC.type;
      } else {
        composeType = composeIFC;
        composeIFC = {};
      }

      var wrapWithList = false;
      if (Array.isArray(composeType)) {
        if (composeType.length !== 1) {
          throw new Error(`${typeName}.${fieldName} can accept Array exact with one input type definition`);
        }
        wrapWithList = true;
        composeType = composeType[0];

        if (Array.isArray(composeType)) {
          throw new Error(`${typeName}.${fieldName} definition [[Type]] (array of array) does not supported`);
        }
      }

      if (composeType instanceof _typeComposer2.default) {
        throw new Error(`You cannot provide TypeComposer to the field '${typeName}.${fieldName}'. It should be InputType.`);
      }

      var fieldConfig = {};
      if (typeof composeType === 'string') {
        if (RegexpOutputTypeDefinition.test(composeType)) {
          throw new Error(`${typeName}.${fieldName} should be InputType, but got output type definition '${composeType}'`);
        }

        var type = RegexpInputTypeDefinition.test(composeType) || RegexpEnumTypeDefinition.test(composeType) ? this.createType(composeType) : this.getWrapped(composeType);

        if (!type) {
          throw new Error(`${typeName}.${fieldName} cannot convert to InputType the following string: '${composeType}'`);
        }

        // $FlowFixMe
        fieldConfig.type = type;
      } else if (composeType instanceof _inputTypeComposer2.default) {
        fieldConfig.type = composeType.getType();
      } else {
        fieldConfig.type = composeType;
      }

      if (!fieldConfig.type) {
        throw new Error(`${typeName}.${fieldName} must have some 'type'`);
      }

      if (!(0, _is.isFunction)(fieldConfig.type)) {
        if (!isInputType(fieldConfig.type)) {
          throw new Error(`${typeName}.${fieldName} provided incorrect InputType: '${JSON.stringify(composeType)}'`);
        }

        if (wrapWithList) {
          fieldConfig.type = new _graphql.GraphQLList(fieldConfig.type);
        }
      }

      if ((0, _is.isObject)(composeIFC)) {
        // copy all other props
        var doNotCopy = ['type'];
        for (var prop in composeIFC) {
          if (composeIFC.hasOwnProperty(prop) && doNotCopy.indexOf(prop) === -1) {
            fieldConfig[prop] = composeIFC[prop];
          }
        }
      }

      return fieldConfig;
    }
  }, {
    key: 'convertInputFieldConfigMap',
    value: function convertInputFieldConfigMap(composeFields) {
      var _this3 = this;

      var typeName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      var fields = {};
      Object.keys(composeFields).forEach(function (name) {
        fields[name] = _this3.convertInputFieldConfig(composeFields[name], name, typeName);
      });

      return fields;
    }
  }]);
  return TypeMapper;
}();

var typeMapper = new TypeMapper();
exports.default = typeMapper;


function parseTypes(astDocument) {
  var types = [];
  for (var i = 0; i < astDocument.definitions.length; i++) {
    var def = astDocument.definitions[i];
    types[i] = makeSchemaDef(def);
  }
  return types;
}

function typeFromAST(inputTypeAST) {
  var innerType = void 0;
  if (inputTypeAST.kind === _kinds.LIST_TYPE) {
    innerType = typeFromAST(inputTypeAST.type);
    return innerType && new _graphql.GraphQLList(innerType);
  }
  if (inputTypeAST.kind === _kinds.NON_NULL_TYPE) {
    innerType = typeFromAST(inputTypeAST.type);
    return innerType && new _graphql.GraphQLNonNull(innerType);
  }
  (0, _invariant2.default)(inputTypeAST.kind === _kinds.NAMED_TYPE, 'Must be a named type.');
  return typeMapper.get(inputTypeAST.name.value);
}

function typeDefNamed(typeName) {
  var type = typeMapper.get(typeName);
  if (type) {
    return type;
  }
  throw new Error(`Cannot find type with name '${typeName}' in TypeMapper.`);
}

function makeSchemaDef(def) {
  if (!def) {
    throw new Error('def must be defined');
  }

  switch (def.kind) {
    case _kinds.OBJECT_TYPE_DEFINITION:
      return makeTypeDef(def);
    // case INTERFACE_TYPE_DEFINITION:
    //   return makeInterfaceDef(def);
    case _kinds.ENUM_TYPE_DEFINITION:
      return makeEnumDef(def);
    // case UNION_TYPE_DEFINITION:
    //   return makeUnionDef(def);
    // case SCALAR_TYPE_DEFINITION:
    //   return makeScalarDef(def);
    case _kinds.INPUT_OBJECT_TYPE_DEFINITION:
      return makeInputObjectDef(def);
    default:
      throw new Error(`Type kind "${def.kind}" not supported.`);
  }
}

function makeInputValues(values) {
  return (0, _keyValMap2.default)(values, function (value) {
    return value.name.value;
  }, function (value) {
    var type = produceInputType(value.type);
    return {
      type,
      description: (0, _buildASTSchema.getDescription)(value),
      defaultValue: (0, _graphql.valueFromAST)(value.defaultValue, type)
    };
  });
}

function makeFieldDefMap(def) {
  return (0, _keyValMap2.default)(def.fields, function (field) {
    return field.name.value;
  }, function (field) {
    return {
      type: produceOutputType(field.type),
      description: (0, _buildASTSchema.getDescription)(field),
      args: makeInputValues(field.arguments),
      deprecationReason: getDeprecationReason(field.directives)
    };
  });
}

function makeEnumDef(def) {
  var enumType = new _graphql.GraphQLEnumType({
    name: def.name.value,
    description: (0, _buildASTSchema.getDescription)(def),
    values: (0, _keyValMap2.default)(def.values, function (enumValue) {
      return enumValue.name.value;
    }, function (enumValue) {
      return {
        description: (0, _buildASTSchema.getDescription)(enumValue),
        deprecationReason: getDeprecationReason(enumValue.directives)
      };
    })
  });

  return enumType;
}

function makeInputObjectDef(def) {
  return new _graphql.GraphQLInputObjectType({
    name: def.name.value,
    description: (0, _buildASTSchema.getDescription)(def),
    fields: function fields() {
      return makeInputValues(def.fields);
    }
  });
}

function getNamedTypeAST(typeAST) {
  var namedType = typeAST;
  while (namedType.kind === _kinds.LIST_TYPE || namedType.kind === _kinds.NON_NULL_TYPE) {
    namedType = namedType.type;
  }
  return namedType;
}

function buildWrappedType(innerType, inputTypeAST) {
  if (inputTypeAST.kind === _kinds.LIST_TYPE) {
    return new _graphql.GraphQLList(buildWrappedType(innerType, inputTypeAST.type));
  }
  if (inputTypeAST.kind === _kinds.NON_NULL_TYPE) {
    var wrappedType = buildWrappedType(innerType, inputTypeAST.type);
    (0, _invariant2.default)(!(wrappedType instanceof _graphql.GraphQLNonNull), 'No nesting nonnull.');
    return new _graphql.GraphQLNonNull(wrappedType);
  }
  return innerType;
}

function produceOutputType(typeAST) {
  var type = produceType(typeAST);
  (0, _invariant2.default)(isOutputType(type), 'Expected Output type.');
  return type;
}

function produceType(typeAST) {
  var typeName = getNamedTypeAST(typeAST).name.value;
  var typeDef = typeDefNamed(typeName);
  return buildWrappedType(typeDef, typeAST);
}

function produceInputType(typeAST) {
  var type = produceType(typeAST);
  (0, _invariant2.default)(isInputType(type), 'Expected Input type.');
  return type;
}

function produceInterfaceType(typeAST) {
  var type = produceType(typeAST);
  (0, _invariant2.default)(type instanceof _graphql.GraphQLInterfaceType, 'Expected Object type.');
  return type;
}

function makeImplementedInterfaces(def) {
  return def.interfaces && def.interfaces.map(function (iface) {
    return produceInterfaceType(iface);
  });
}

function makeTypeDef(def) {
  var typeName = def.name.value;
  return new _graphql.GraphQLObjectType({
    name: typeName,
    description: (0, _buildASTSchema.getDescription)(def),
    fields: function fields() {
      return makeFieldDefMap(def);
    },
    interfaces: function interfaces() {
      return makeImplementedInterfaces(def);
    }
  });
}

function getDeprecationReason(directives) {
  var deprecatedAST = directives && (0, _find2.default)(directives, function (directive) {
    return directive.name.value === _graphql.GraphQLDeprecatedDirective.name;
  });
  if (!deprecatedAST) {
    return;
  }

  var _getArgumentValues = (0, _values.getArgumentValues)(_graphql.GraphQLDeprecatedDirective, deprecatedAST),
      reason = _getArgumentValues.reason;

  return reason; // eslint-disable-line
}