'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

exports.removeWrongFields = removeWrongFields;
exports.toInputObjectType = toInputObjectType;
exports.convertInputObjectField = convertInputObjectField;

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _graphql = require('./graphql');

var _typeComposer = require('./typeComposer');

var _typeComposer2 = _interopRequireDefault(_typeComposer);

var _inputTypeComposer = require('./inputTypeComposer');

var _inputTypeComposer2 = _interopRequireDefault(_inputTypeComposer);

var _generic = require('./type/generic');

var _generic2 = _interopRequireDefault(_generic);

var _misc = require('./utils/misc');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-use-before-define, prefer-template */

function removeWrongFields(fields) {
  var result = {};
  Object.keys(fields).forEach(function (key) {
    var field = fields[key];
    if (!(0, _graphql.isAbstractType)(field.type) && // skip interface fields
    !field._gqcResolver // skip fields that obtained via Resolver
    ) {
        result[key] = field;
      }
  });
  return result;
}

function toInputObjectType(typeComposer) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var cache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Map();

  if (typeComposer.hasInputTypeComposer()) {
    return typeComposer.getInputTypeComposer();
  }

  var prefix = opts.prefix || '';
  var postfix = opts.postfix || 'Input';

  var inputTypeName = `${prefix}${typeComposer.getTypeName()}${postfix}`;
  if (cache.has(typeComposer.getType())) {
    // $FlowFixMe
    return cache.get(typeComposer.getType());
  }

  var inputTypeComposer = new _inputTypeComposer2.default(new _graphql.GraphQLInputObjectType({
    name: inputTypeName,
    fields: {}
  }));
  cache.set(typeComposer.getType(), inputTypeComposer);

  var outputFields = removeWrongFields(typeComposer.getFields());
  var inputFields = {};
  Object.keys(outputFields).forEach(function (key) {
    var fieldOpts = (0, _extends3.default)({}, opts, {
      fieldName: key,
      outputTypeName: typeComposer.getTypeName()
    });
    inputFields[key] = convertInputObjectField(outputFields[key], fieldOpts, cache);
  });
  inputTypeComposer.addFields(inputFields);

  return inputTypeComposer;
}

function convertInputObjectField(field, opts, cache) {
  var fieldType = field.type;

  var wrappers = [];
  while (fieldType instanceof _graphql.GraphQLList || fieldType instanceof _graphql.GraphQLNonNull) {
    wrappers.unshift(fieldType.constructor);
    fieldType = fieldType.ofType;
  }

  if (!(0, _graphql.isInputType)(fieldType)) {
    if (fieldType instanceof _graphql.GraphQLObjectType) {
      var typeOpts = {
        prefix: `${opts.prefix || ''}${(0, _misc.upperFirst)(opts.outputTypeName || '')}`,
        postfix: opts.postfix || 'Input'
      };
      var typeComposer = new _typeComposer2.default(fieldType);
      fieldType = toInputObjectType(typeComposer, typeOpts, cache).getType();
    } else {
      // eslint-disable-next-line
      console.error(`GQC: can not convert field '${opts.outputTypeName || ''}.${opts.fieldName || ''}' to InputType` + '\nIt should be GraphQLObjectType, but got \n' + _util2.default.inspect(fieldType, { depth: 2, colors: true }));
      fieldType = _generic2.default;
    }
  }

  var inputFieldType = wrappers.reduce(function (type, Wrapper) {
    return new Wrapper(type);
  }, fieldType);

  return { type: inputFieldType, description: field.description };
}